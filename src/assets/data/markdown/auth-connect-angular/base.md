# Lab: The Base Application

This training starts with an Ionic Framework application that uses standard `email/password` with a remote hosted server for authentication. This is a common paradigm used in web applications. In this lab, we will add SSO with Auth0 capability for authentication.

## Getting Started

These instrctions assume that you have a reasonable development environment set up on your machine including `git`, `node`, `npm`, and `Android Studio`. If your are using a Mac and want to build for iOS, you should also have `Xcode`, the Xcode commandline tools, and `cocoapods`.

To get started, perform the following actions within a working folder:

- `git clone https://github.com/ionic-team/ac-training-starter.git`
- `cd ac-training-starter`
- `npm i`
- `npm run build`
- `npx cap update` - this may take a while
- `npm run build`
- `npm start` - to run in the browser

To build for installation on a device, use `npx cap open android` or `npx cap open ios`. This will open the project in the appropriate IDE. From there you can build the native application and install it on your device.

## General Architecture

### Services

Two services are related to the authentication workflow. The `AuthenticationService` handles the API calls that perform login actions. The `IdentiyService` handles the identity of the currently logged in user.

#### AuthenticationService

The `AuthenticationService` handles the POSTs to the login endpoint. If this operation is successful it registers this fact with the `IdentityService`. This is the first of two services used in this training, so let's look at it a bit more in depth.

##### Construction

This service is registered with the dependency injection engine such that it is available to the whole application. This service exposes various methods that can be called to perform authentication actions. Currently, supports a `login()` action.

##### `login()` - Attempt to login with email and password

Makes a call to the API that will attempt to login the user using `email` and `password` credentials. If successful, the server will respond with an authentication token that we save into our identityService where it can be referenced by other parts of the application when needed. When then map the response to `true` to notify the caller that the result of the operation was successful.

```TypeScript
login(username: string, password: string): Observable<boolean> {
    return this.http.post(`${environment.dataService}/auth/login`, {
        username,
        password
    }, {
        responseType: 'text'
    }).pipe(
        map(token => this.identityService.newIdentity(token)),
        mapTo(true)
    );
}
```

#### IdentityService

The `IdentityService` defines the identity of the currently logged in user including the authentication token associated with the user. This service also persists the token so it is available between sessions. This is the second service used in this training, so let's examine it feature by feature.

##### Construction

This service is registered with the dependency injection engine such that it is availale to the whole application. All of the data controlled by this service is private. Consumers must interact with the data via the public methods. A `changed` subject is created so other parts of the application can know when the user has changed, allowing then to requery data as needed.

```TypeScript
@Injectable({
  providedIn: 'root'
})
export class IdentityService {
  private tokenKey = 'auth-token';
  private token: string;
  private user: User;

  changed: Subject<User>;

  constructor(private http: HttpClient, private storage: Storage) {
    this.changed = new Subject();
  }
  ...
}
```

##### `set()` - Set the Current User and Token

The `set()` method takes a `User` object and a token. The `User` object is cached locally and the token is stored in a local storage mechanism. The `changed` subject is also fired. This method should be called as part of the login workflow.

```TypeScript
  async set(user: User, token: string): Promise<void> {
    this.user = user;
    await this.setToken(token);
    this.changed.next(this.user);
  }
```

##### `get()` - Get the Current User

Our API has a `users/current` endpoint that returns the `User` that is assciated with whichever authentication token is sent in the request. Our application will then do one of the following with any `get()` call:

- A `User` will already be cached (either from a `set()` call or a prior `get()` call), that user will be returned
- A `User` is not cached so we make an API call to get the user, in which case:
  - An HTTP interceptor applies the currently stored token
  - The call returns the user associated with that token and the user is cached
  - If a token does not exist or is invalid, a 401 is generated by the API

```TypeScript
get(): Observable<User> {
    if (!this.user) {
        return this.http
            .get<User>(`${environment.dataService}/user/current`)
            .pipe(
                catchError(e => of(null)),
                tap(u => (this.user = u))
            );
    } else {
        return of(this.user);
    }
}
```

This allows our application to retrieve information about the currently logged in user after a restart. This method could be called as part of the bootstrap workflow or at any other time that data about the currently logged in user is required.

##### `getToken()` - Get the Current Token

The `getToken()` method returns the currently set token. If no token is currently set, it attempts to retrieve a token from a local storage mechanism.

```TypeScript
  async getToken(): Promise<string> {
    if (!this.token) {
      await this.storage.ready();
      this.token = await this.storage.get(this.tokenKey);
    }
    return this.token;
  }
```

This method is most commonly used whenever an HTTP call is made so the token can be added to the headers of the call. In this application, the logic that performs that action has been abstracted into an HTTP interceptor.

##### `remove()` - Remove the User and the Token

The user and the token are removed from memory and from the local storage mechanism.

```TypeScript
  async remove(): Promise<void> {
    this.user = undefined;
    await this.setToken('');
    this.changed.next(this.user);
  }
```

This method should be called as part of the login workflow.

### Additional Classes

#### AuthInterceptor

This HTTP Interceptor adds the authentication token to the outgoing requests that require a token. For this application, that is every request that is not itself the `login` request.

#### LoggedInGuard

This guard is attached to routes that we want to only allow access to when the user is authenticated. If the user is not authenticated, they will be redirected to the login page.

### Application Workflow

#### Startup

Upon starting up, the application attempts to load the `HomePage`. Three scenarios are possible at this point:

- A valid token has been stored from a previous session and the User data is available
- A token has been stored from a previous session but is invalid and will not load the User data
- A token has not been stored from a previous session

In the first scenario, the `HomePage` successfully loads and displays the username of the current user. In the last two scenarios, the system will be unable to restore the user data from the server and the `LoggedInGuard` will prevent the user from accessing any secured pages and redirect them to the login page.
